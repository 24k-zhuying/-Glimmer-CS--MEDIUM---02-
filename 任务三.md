* 做题历程
这道题花费大概三到四小时，有前面的基础的情况下做题较顺畅但除了一点，那就是前面提到的当小叔部分第一位为0时的问题，这个点花费时间最长，想了很久才想到可以勉强解决的办法，但依旧是治标不治本除了重新做感觉没有什么好的方法了，太难受了。。。大部分函数都跟前面几道题是一样的学长可以不用重复看。由于文件中已全部转化为十进制所以有些函数相对优化了一下去除了判断二进制的情况

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

//该结构体用于表示定点数，包含符号位、整数部分和小数部分
typedef struct{
    int sign;              //符号位，1表示负数，0表示正数
    unsigned int zhengShu;   //32位无符号整数，用于存储定点数的整数部分
    unsigned int xiaoShu;  //32位无符号整数，用于存储定点数的小数部分
}PointFixedNum;

//全局变量用于判断小数部分第一个数是否为零
int zero = 1;

//init函数用于初始化PointFixedNum结构体
//num是指向要初始化的PointFixedNum结构体的指针
//input是输入的字符串
void init(PointFixedNum *num, char *input);

//用于去除数据末尾多余的0(直接引用了任务1写的函数)
void removeZero(char *str);

//将输入的字符串中的操作数和符号提取出来
void stringPut(char input[], char str1[], char str2[], char *fuhao);

//加法函数
void add(PointFixedNum *num1,PointFixedNum *num2,PointFixedNum *result);

//将字符串中的数字转化为int类型并判断是否溢出
unsigned int strSwitch(char *str);

//减法函数
void subtruct(PointFixedNum *num1,PointFixedNum *num2,PointFixedNum *result);

//乘法函数
void multiply(PointFixedNum *num1, PointFixedNum *num2, PointFixedNum *result);
//该函数可以将运算中途的结果由结构体中存到字符串中以便连续运算
void structSwitchStr(PointFixedNum *result,char str[]);

int main(){
    //打开原始文件用于读取并做错误处理
    FILE *mainFile = fopen("./files/CS_M_02.txt", "r");

    if(mainFile == NULL){
        perror("file open failed:");
        return 0;
    }
    //用于存放运算式
    char numsStr[50];
    numsStr[0] = '\0';
    //用于临时存放一行的字符串
    char tempStr[25];
    //先读取一行字符串存到numsStr中以便后续再读取一行能凑出完整的运算式
    if(fgets(tempStr,sizeof(tempStr),mainFile) != NULL){
        strcat(numsStr,tempStr);
        //将numsStr后的换行符去掉
        numsStr[strlen(numsStr)-1] = numsStr[strlen(numsStr)];     
    }
    else{
        printf("读取错误");
    }

    //定义存储字符串中的运算数和运算符
    char str1[50],str2[50];
    char fuhao;
    char *p = &fuhao;
    //定义结构体分别存储运算数和最终结果
    PointFixedNum num1;
    PointFixedNum num2;
    PointFixedNum result;
    
    while(fgets(tempStr,sizeof(tempStr),mainFile) != NULL){
        //将新读取的数拼接到numsStr后面
        strcat(numsStr,tempStr);
        //提取操作数和操作符
        stringPut(numsStr,str1,str2,p);
        //初始化结构体
        init(&num1,str1);
        init(&num2,str2);
        //将numsStr重新初始化便于下次存储
        numsStr[50] = '\0';

        //根据运算符进行运算
        if(fuhao == '+'){
            add(&num1,&num2,&result);
        }

        if(fuhao == '-'){
            subtruct(&num1,&num2,&result);
        }

        if(fuhao == '*'){
            multiply(&num1,&num2,&result);
        }
        //将运算结果存入字符串便于下次运算
        structSwitchStr(&result,numsStr);
        //每运算一次进行一次输出
        printf("%s\n",numsStr);

    }

    return 0;
}
    
//将输入的字符串中的操作数和符号提取出来
void stringPut(char input[], char str1[], char str2[], char *fuhao){
    int i = 0;
    int temp1 = 0;
    int temp2 = 0;
    int len1 = 0;
    int len2 = 0;
    //遍历字符串提取第一个操作数
    for(i; ;i++){
        if(input[i] == 'D'){
            str1[len1++] = input[i];
            break;
        }

        str1[len1++] = input[i];
    }
    str1[len1] = '\0';
    //继续遍历字符串提取操作符
    for(i; ;i++){
        if(input[i] == '-' || input[i] == '+' || input[i] == '*'){
            *fuhao = input[i++];
            break;
        }
    }
    //继续遍历提取第二个操作数
    for(i; ;i++){
        if(input[i] == ' '){
            continue;
        }
        if(input[i] == 'D'){
            str2[len2++] = input[i];
            break;
        }
        str2[len2++] = input[i];
    }
    str2[len2] = '\0';
}    
//init函数用于初始化PointFixedNum结构体
//num是指向要初始化的PointFixedNum结构体的指针
//input是输入的字符串
void init(PointFixedNum *num, char *input){
    //使用strdup函数复制输入字符串，以便后续操作
    char *numsStr = strdup(input);
    //查看输入的数字是否为负数将结构体中的sign赋值   
    if(numsStr[0] == '-'){
        num->sign = 1;
        //若为负数将字符串中的负号去掉
        for(int i=0; i<strlen(numsStr) - 1; i++){
            numsStr[i] = numsStr[i+1];
        }
        numsStr[strlen(numsStr)-1] = '\0';
    }else{
        num->sign = 0;
    }
    //如果输入字符串的最后一个字符是'D'，表示输入的是十进制数
    if(input[strlen(input)-1] == 'D'){
        //将复制后的字符串末尾的'D'字符去掉，使其成为一个纯数字字符串
        numsStr[strlen(numsStr)-1] = '\0';
        //在纯数字字符串中查找小数点的位置
        char *dotPos = strchr(numsStr,'.');
        //若数字有小数部分
        if(dotPos){
            //定义两个分别存储小数部分和整数部分的字符串
            char xiaoShuStr[200],zhengShuStr[200];
            //遍历字符串提取整数部分
            int i=0;
            for(; ;i++){
                if(numsStr[i] == '.'){
                    break;
                }
                zhengShuStr[i] = numsStr[i];
            }
            zhengShuStr[i] = '\0';
            
            //利用dotPos指针提取小数部分
            int j=0;
            for(; ; j++){
                dotPos++;
                if( *dotPos == '\0' ){
                    break;
                }
                xiaoShuStr[j] = *dotPos;
            }
            xiaoShuStr[j] = '\0';
            
            //利用strSwitch函数将整数和小数部分的字符串转化为int类型并存入结构体           
            num->zhengShu = strSwitch(zhengShuStr);
            num->xiaoShu = strSwitch(xiaoShuStr);
        }
        //若数字没有小数部分
        else{
            num->zhengShu = strSwitch(numsStr);
            num->xiaoShu = 0;
        }
    }
    
    free(numsStr);
}
//用于去除数据末尾多余的0(直接引用了任务1写的函数)
void removeZero(char *str) {
    // 计算字符串长度
    int len = strlen(str);
    // 当字符串长度大于1且最后一个字符是0时
    while (len > 1 && str[len - 1] == '0') {
        // 将最后一个字符置为空字符（即删除该字符）
        str[len - 1] = '\0';
        // 字符串长度减1
        len--;
    }
    // 如果最后一个字符是小数点
    if (str[len - 1] == '.') {
        // 将最后一个字符置为空字符（即删除该字符）
        str[len - 1] = '\0';
    }
}
//将字符串中的数字转化为int类型并判断是否溢出
unsigned int strSwitch(char *str) {
    unsigned int num = 0;
    int i = 0;
    while (str[i]!= '\0') {
        //判断溢出，对于无符号整数，只要大于UINT_MAX / 10，或者等于UINT_MAX / 10且下一位大于UINT_MAX % 10就溢出
        //该种判断方法由查阅得出的
        if (num > UINT_MAX / 10 || (num == UINT_MAX / 10 && (str[i] - '0') > UINT_MAX % 10)) {
            printf("溢出发生\n");
            return UINT_MAX;
        }
        num = num * 10+(str[i] - '0');
        i++;
    }
    return num;
}
//加法函数
void add(PointFixedNum *num1,PointFixedNum *num2,PointFixedNum *result){
    //记录第一个加数小数部分的位数
    unsigned int temp = num1->xiaoShu;
    int cnt1 = 0;
    while (temp > 0){
        temp /= 10;
        cnt1++;
    }
    if(zero == 0){
        cnt1++;
        zero = 1;
    }
    //记录第二个加数小数部分的位数
    temp = num2->xiaoShu;   
    int cnt2 = 0;
    while (temp > 0){
        temp /= 10;
        cnt2++;
    }
    int cntMax = cnt1>cnt2?cnt1:cnt2; 
    unsigned long long tempXiao;
    //小数部分相加（其中要考虑高位对高位所以有条件判断谁的位数高）
    if(cnt1 > cnt2){
        tempXiao = (unsigned long long)num1->xiaoShu + (unsigned long long)num2->xiaoShu*pow(10,cnt1-cnt2);
    }
    else{
        tempXiao = (unsigned long long)num2->xiaoShu + (unsigned long long)num1->xiaoShu*pow(10,cnt1-cnt2);
    }
    //判断溢出
    if(tempXiao > pow(2,32)-1){
        printf("发生溢出");
    }
    //如果小数部分有进位
    int jinWei = 0;
    if(tempXiao >= pow(10,cntMax)){
        tempXiao -= pow(10,cntMax);
        jinWei = 1;
    }
    //判断第一位是否为0
            temp = tempXiao;   
            int cnt3 = 0;
            while (temp > 0){
            temp /= 10;
            cnt3++;
            }  
            if(cnt1 != cnt2 && cnt3 != cntMax){
                zero = 0;
            }
    //将计算结果存入结构体中
    result->zhengShu = num1->zhengShu + num2->zhengShu +jinWei;
    result->xiaoShu = (unsigned int)tempXiao;

    return;
}
//减法函数
void subtruct(PointFixedNum *num1,PointFixedNum *num2,PointFixedNum *result){
    //记录第一个加数小数部分的位数
    unsigned int temp = num1->xiaoShu;
    int cnt1 = 0;
    while (temp > 0){
        temp /= 10;
        cnt1++;
    }
    //记录第二个加数小数部分的位数
    temp = num2->xiaoShu;   
    int cnt2 = 0;
    while (temp > 0){
        temp /= 10;
        cnt2++;
    }
    int cntMax = cnt1>cnt2?cnt1:cnt2;

    int jieWei = 0;
    //若两数同号作减法
    if(num1->sign == num2->sign){    
        //临时存储小数部分计算结果
        unsigned long long int temp1;   
        //若被减数大于等于减数 
        if(num1->zhengShu >= num2->zhengShu){
        //当被减数的小数部分小于减数的小数部分时需要借位
            if(((cnt1 == cnt2) && (num1->xiaoShu < num2->xiaoShu))||
                ((num1->xiaoShu * pow(10,cnt2)<num2->xiaoShu * pow(10,cnt1))&&(cnt1 != cnt2))){
                
                //算出小数部分最终结果（如减数的小数部分为2被减数小数部分为1，就等于pow(10,1)-2+1)
                temp1 = (unsigned long long int)pow(10,cnt1+cnt2) - 
                (unsigned long long int)num2->xiaoShu*pow(10,cnt1) + (unsigned long long int)num1->xiaoShu*pow(10,cnt2);
                //整数部分减去借位的值
                jieWei = 1;
            }
            //当被减数的小数部分不小于减数的小数部分时不需要借位
            else{
                temp1 = (unsigned long long int)num1->xiaoShu*pow(10,cnt2) 
                - (unsigned long long int)num2->xiaoShu*pow(10,cnt1);
            }
            //去掉末尾的0
            while(temp1 % 10 == 0){
                temp1 /= 10;
            }
            //判断第一位是否为0
            temp = temp1;   
            int cnt3 = 0;
            while (temp > 0){
            temp /= 10;
            cnt3++;
            }  
            if(cnt1 != cnt2 && cnt3 != cntMax){
                zero = 0;
            }
            //将小数部分的运算结果存入结构体
            result->xiaoShu = (unsigned int)temp1;
            //将整数部分的运算结果存入结构体
                result->zhengShu = num1->zhengShu - num2->zhengShu - jieWei;
                result->sign = 0;                 
        }
        //若被减数小于减数（相当于将交换减数和被减数）
        else{
            //当被减数的小数部分小于减数的小数部分时需要借位
            if(((cnt1 == cnt2) && (num2->xiaoShu < num1->xiaoShu))||
                ((num1->xiaoShu * pow(10,cnt2)>num2->xiaoShu * pow(10,cnt1))&&(cnt1 != cnt2))){
                
                //算出小数部分最终结果（如减数的小数部分为2被减数小数部分为1，就等于pow(10,1)-2+1)
                temp1 = pow(10,cnt1+cnt2) - num1->xiaoShu*pow(10,cnt1) + num2->xiaoShu*pow(10,cnt2);
                //整数部分减去借位的值
                jieWei = 1;
            }
            //当被减数的小数部分不小于减数的小数部分时不需要借位
            else{
                temp1 = num2->xiaoShu*pow(10,cnt2) - num1->xiaoShu*pow(10,cnt1);
            }
            //去掉末尾的0
            while(temp1 % 10 == 0){
                temp1 /= 10;
            }
            //将小数部分的运算结果存入结构体
            result->xiaoShu = temp1;
            //将整数部分的运算结果存入结构体
            result->zhengShu = num1->zhengShu - num2->zhengShu - jieWei;                            
            result->sign = 1;
        }            
    }
    //若两数异号相当于加法
    if(num1->sign != num2->sign){
        //若第一个数为正数第二个数为负数
        if(num1->sign == 0){
            add(num1,num2,result);
            return;
        }
        //若第一个数为负数第二个数为正数
        if(num1->sign == 1){
            add(num1,num2,result);
            result->sign = 1;
            return;
        }
    }
    return;
}
//第一个数为被乘数第二个数为乘数
void multiply(PointFixedNum *num1, PointFixedNum *num2, PointFixedNum *result){
    //先存入计算结果的正负
    result->sign = ((num1->sign == num2->sign)?0:1);
    //将被乘数的整数部分和小数部分合并为一个数方便后续乘法运算
    unsigned int temp = num1->xiaoShu;
    //记录被乘数小数点后有几位
    int cnt1 = 0;
    while (temp > 0){
        temp /= 10;
        cnt1++;
    }
    //合并的同时去掉小数点方便后续运算
    unsigned int long long temp1 = (unsigned int long long)(num1->zhengShu * pow(10,cnt1) + num1->xiaoShu);
    //将乘数的整数部分和小数部分合并为一个数方便后续乘法运算
    temp = num2->xiaoShu;
    //记录乘数小数点后有几位
    int cnt2 = 0;
    while (temp > 0){
        temp /= 10;
        cnt2++;
    }
    //合并的同时去掉小数点方便后续运算
    unsigned int long long temp2 = (unsigned int long long)(num2->zhengShu * pow(10,cnt2) + num2->xiaoShu);
    //存储计算结果
    unsigned int long long tempResult = 0;
    //用于记录下面乘法运算循环的次数用于移位
    int count = 0;

    while(temp2 != 0){
        //记录乘数的最后一位数字使其与被乘数相乘
        int lastWei = temp2 % 10;
        //记录后将乘数最后一位数字去掉
        temp2 /= 10;
        //核心运算（乘数最后一位乘以被乘数，再移位补零加上原来的结果）
        tempResult += (lastWei * temp1) * pow(10,count);
        count++;
    }        
    //溢出判断
    if(tempResult > pow(2,32)-1){
        printf("发生溢出");
        return;
    }
    //利用乘数和被乘数小数部分位数之和在合适的地方加上小数点
    //并将整数部分和小数本分存入结构体中
    result->zhengShu = (unsigned int)(tempResult / pow(10,cnt1+cnt2));
    result->xiaoShu = (unsigned int)(tempResult % (unsigned int long long)pow(10,cnt1+cnt2));
    
    //小数部分末尾去掉多余的0
    while(result->xiaoShu % 10 == 0){
        result->xiaoShu /= 10;
    }

    return;
}
//该函数可以将运算中途的结果由结构体中存到字符串中以便连续运算
void structSwitchStr(PointFixedNum *result,char str[]){
    //若小数部分为零
    if(result->xiaoShu == 0){
        sprintf(str,"%uD",result->zhengShu);
    }
    //若小数部分不为0
    if(result->xiaoShu != 0){
        if(zero == 0){
            sprintf(str,"%u.0%uD",result->zhengShu,result->xiaoShu);
        }
        else{
            sprintf(str,"%u.%uD",result->zhengShu,result->xiaoShu);
        }    
    }
    //重新初始化结构体
    result->sign = 0;
    result->xiaoShu = 0;
    result->zhengShu = 0;

    return;
}